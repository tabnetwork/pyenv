import os
import shutil
import subprocess
import tempfile
from contextlib import contextmanager
from packaging import version
from pathlib import Path


@contextmanager
def working_directory(path):
    prev_cwd = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(prev_cwd)


def python_exes(suffixes=None):
    if suffixes is None:
        suffixes = [""]
    else:
        suffixes.append("")
    for suffix in suffixes:
        yield f'python{suffix}.exe'
        yield f'pythonw{suffix}.exe'


def script_exes(ver):
    for suffix in ['', f'{ver.major}', f'{ver.major}.{ver.minor}']:
        yield f'pip{suffix}.exe'
    for suffix in ['', f'-{ver.major}.{ver.minor}']:
        yield f'easy_install{suffix}.exe'


def touch(exe):
    with open(exe, 'a'):
        os.utime(exe, None)


def pyenv_setup(settings):
    pyenv_path, local_path, versions, global_ver, local_ver =\
        settings['pyenv_path'],\
        settings['local_path'],\
        settings.get('versions', None),\
        settings.get("global_ver", None),\
        settings.get('local_ver', None)
    if versions is None:
        versions = []
    src_path = Path(__file__).resolve().parents[1].joinpath('pyenv-win')
    dirs = [r'bin', r'libexec\libs', r'shims', r'versions']
    for d in dirs:
        os.makedirs(Path(pyenv_path, d))
    _, _, libexec_files = next(os.walk(src_path.joinpath('libexec')))
    for f in libexec_files:
        shutil.copy(Path(src_path, 'libexec', f), Path(pyenv_path, 'libexec', f))
    files = [r'bin\pyenv.bat',
             r'libexec\pyenv-shell.bat',
             r'libexec\libs\pyenv-install-lib.vbs',
             r'libexec\libs\pyenv-lib.vbs']
    for f in files:
        shutil.copy(src_path.joinpath(f), Path(pyenv_path, f))
    versions_dir = Path(pyenv_path, r'versions')

    def create_pythons(path):
        os.mkdir(path)
        for exe in python_exes([f'{ver.major}', f'{ver.major}{ver.minor}', f'{ver.major}.{ver.minor}']):
            touch(path.joinpath(exe))
        with open(path.joinpath('version.bat'), "w") as batch:
            print(f"@echo {ver.major}.{ver.minor}.{ver.micro}", file=batch)
        return path

    def create_scripts(path):
        os.mkdir(path)
        for exe in script_exes(ver):
            touch(path.joinpath(exe))
        with open(path.joinpath('hello.bat'), "w") as batch:
            print("@echo Hello world!", file=batch)
        with open(path.joinpath('version.bat'), "w") as batch:
            print(f"@echo {ver.major}.{ver.minor}.{ver.micro}", file=batch)

    for v in versions:
        ver = version.parse(v)
        version_path = create_pythons(versions_dir.joinpath(v))
        create_scripts(version_path.joinpath('Scripts'))
    if global_ver is not None:
        with open(Path(pyenv_path, "version"), "w") as f:
            print(global_ver, file=f)
    if local_ver is not None:
        with open(Path(local_path, ".python-version"), "w") as f:
            print(local_ver, file=f)


class PyenvContext:
    def __init__(self, exec, pyenv, pyenv_path, local_path):
        self.exec = exec
        self.pyenv = pyenv
        self.pyenv_path = pyenv_path
        self.local_path = local_path


class TempPyEnv:
    def __init__(self, settings):
        self.tmp_path = tempfile.TemporaryDirectory()
        touch(Path(self.tmp_path.name, '.python-version'))
        settings['pyenv_path'] = pyenv_path = Path(self.tmp_path.name, 'pyenv dir with spaces')
        settings['local_path'] = local_path = Path(self.tmp_path.name, 'local dir with spaces')
        os.mkdir(pyenv_path)
        os.mkdir(local_path)
        pyenv_setup(settings)
        self.prev_cwd = os.getcwd()
        os.chdir(local_path)
        self.bat = Path(pyenv_path, r'bin\pyenv.bat')
        self.context = PyenvContext(self.exec, self.pyenv, pyenv_path, local_path)

    def pyenv(self, pyenv_args=None):
        args = [str(self.bat)]
        if pyenv_args is not None:
            if isinstance(pyenv_args, list):
                args = args + pyenv_args
            else:
                args.append(pyenv_args)
        return self.exec(args)

    def exec(self, args):
        args = ['cmd', '/d', '/c', 'call', *args]
        result = subprocess.run(args, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stderr = str(result.stderr, "utf-8").strip()
        # \x0c: generated by cls in cmd AutoRun
        stdout = str(result.stdout, "utf-8").rpartition('\x0c')[2].strip("\r\n")
        return stdout, stderr

    def cleanup(self):
        os.chdir(self.prev_cwd)
        self.tmp_path.cleanup()

    def __enter__(self):
        return self.context

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.cleanup()


def run_pyenv_test(settings, commands):
    with TempPyEnv(settings) as context:
        commands(context)


def not_installed_output(ver):
    return (f"pyenv specific python requisite didn't meet. "
            f"Project is using different version of python.\r\n"
            f"Install python '{ver}' by typing: 'pyenv install {ver}'")


def local_python_versions(path):
    with open(Path(path, '.python-version'), mode='r') as f:
        return f.read().strip()
